# AI-Engine Chat API guide

## Introduction

This guide offers details on utilizing the AI-engine's chat API to interact with deltaV. We will demonstrate a python script that interacts 
with deltaV via the chat API, handling session IDs, sending messages, managing responses, and processing user requests and selections.


## Prerequisites

- Before you begin, ensure you have the following:

    - Python version greater than 3.9 and less than 3.11.
    - The requests library installed. You can install it using **pip install requests**.
    - Fauna Token script for getting fauna tokens and refresh tokens.

    Steps to setup `faunatoken.py` script.

    1. Open terminal on your computer and use `mkdir chatAPI` to creat directory.
    2. Create a python script file named `chatapi.py` and include below script in that file. For more information on file please visit [Fauna Token ↗️](../guides/apis/fauna_token)

    ```py copy filename=faunatoken.py
    import threading
    import time
    import requests
    import urllib.parse
    from http.server import BaseHTTPRequestHandler, HTTPServer

    # Constants for the OAuth flow and API interaction.
    FAUNA_URL = 'https://accounts.fetch.ai'
    SCOPE = 'av'
    CLIENT_ID = 'agentverse'
    TOKEN_URL = f'{FAUNA_URL}/v1/tokens'
    REDIRECT_URI = 'http://localhost:8555'
    access_code = None

    class OAuthServer(BaseHTTPRequestHandler):
        def log_message(self, format, *args):
            # Suppress default logging for clarity.
            return

        def do_GET(self):
            global access_code
            parsed = urllib.parse.urlparse(self.path)
            params = urllib.parse.parse_qs(parsed.query)
            if 'code' in params:
                access_code = params['code'][0]
                with open('access_code.txt', 'w') as f:
                    f.write(access_code)
                self.send_response(200)
                self.end_headers()
                self.wfile.write(b'Authentication successful, you may now close this tab.')
            else:
                self.send_response(400)
                self.end_headers()
                self.wfile.write(b'Missing authorization code.')

    def start_server():
        # Starts the HTTP server to handle OAuth redirects.
        server = HTTPServer(('127.0.0.1', 8555), OAuthServer)
        threading.Thread(target=server.serve_forever).start()
        return server

    def get_tokens(auth_code):
        # Exchanges authorization code for access and refresh tokens.
        response = requests.post(
            TOKEN_URL,
            json={
                'grant_type': 'authorization_code',
                'code': auth_code,
                'client_id': CLIENT_ID,
                'redirect_uri': REDIRECT_URI,
                'scope': SCOPE,
            }
        )
        response.raise_for_status()
        fauna_token = response.json()['access_token']
        refresh_token = response.json()['refresh_token']
        return fauna_token, refresh_token

    def refresh_tokens(refresh_token):
        # Uses the refresh token to obtain a new access token and refresh token.
        response = requests.post(
            TOKEN_URL,
            json={
                'grant_type': 'refresh_token',
                'refresh_token': refresh_token,
                'client_id': CLIENT_ID,
                'scope': SCOPE,
            }
        )
        response.raise_for_status()
        fauna_token = response.json()['access_token']
        refresh_token = response.json()['refresh_token']
        return fauna_token, refresh_token

    def get_auth_url():
        # Generates URL for initiating OAuth authorization.
        return f'{FAUNA_URL}/login/?{urllib.parse.urlencode({"redirect_uri": REDIRECT_URI, "client_id": CLIENT_ID, "response_type": "code", "scope": SCOPE})}'

    def shutdown_server(server):
        # Shuts down the OAuth redirect HTTP server.
        server.shutdown()

    if __name__ == '__main__':
        server = start_server()
        print("Please visit the following URL to authenticate:")
        print(get_auth_url())
        # Wait for the user to authenticate and for the server to receive the code
        input("Press Enter after authentication...")
        # Assuming the user has authenticated and 'access_code' has been set
        if access_code:
            fauna_token, refresh_token = get_tokens(access_code)
            print(f'Fauna Tokens : {fauna_token}')
            print(f'Refresh Tokens : {refresh_token}')
            
            new_fauna_token, new_refresh_token = refresh_tokens(refresh_token)
            print(f'New Fauna Tokens : {new_fauna_token}')
            print(f'New Refresh Tokens : {new_refresh_token}')

        shutdown_server(server)
    ```


## Script Break down

This script includes various functions for handling different API interactions. Below is a summary of the main functions and their 
respective purposes.

    - Importing Required libraries:

    ```python
    # Importing Required libraries
    import re
    import requests
    import time
    import json
    from faunatoken import start_server, shutdown_server, get_auth_url, get_tokens, refresh_tokens 
    ```

    These libraries are used to handle user regular expressions, HTTP requests, time delays and JSON responses.

    - normalize_question function:

    ``` python
    # Define function to normalize questions asked by AI-engine
    def normalize_question(question):
        question_lower = question.lower()
        question_normalized = re.sub(r'[^\w\s]', '', question_lower)
        return question_normalized
    ```

    This function converts questions from a JSON response, identified by the key 'text', into lowercase and removes any punctuation. 
    It helps standardize user input for consistent processing.

    - `is_uuid` function:

    ``` python
    # Define function to check if option is uuid (Subtask Key)
    def is_uuid(key):
        # Function to check if a string is a valid UUID
        pattern = re.compile(r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$", re.IGNORECASE)
        return pattern.match(key)
    ```

    This function checks whether the given key is in UUID (Universal Unique Identifier) format.The function uses a regular expression pattern to match the 
    standard UUID format, which consists of 32 hexadecimal characters split into five groups separated by hyphens (8-4-4-4-12).
    
    - `update_token` function

    ```python
    # Function to update and refresh the access token
    def update_token():
        global token, refreshed_token
        new_tokens = refresh_tokens(refreshed_token)
        fauna_token = new_tokens[0]
        refreshed_token = new_tokens[1]
        token = f'Bearer {fauna_token}'
    ```

    This function refreshes the `fauna token` and `refresh fauna token` in case current fauna token expires.

    - `post_request` function

    ```python 
    # Function to handle POST requests with automatic token refresh
    def post_request(url, json_data, headers):
        global token
        response = requests.post(url, json=json_data, headers=headers)
        if response.status_code != 200:
            update_token()
            headers["Authorization"] = token
            response = requests.post(url, json=json_data, headers=headers)
        return response`
    ```

    This function makes post request to Agentverse.

    - `get_request` function

    ```python
    # Function to handle GET requests with automatic token refresh
    def get_request(url, headers):
        global token
        response = requests.get(url, headers=headers)
        if response.status_code != 200:
            update_token()
            headers["Authorization"] = token
            response = requests.get(url, headers=headers)
        return response
    ```
    This function makes get request to Agentverse.

    - send_user_choice_as_uuid function:
    
    ```python
    # Function to send UUID choice message to AI-Engine
    def send_user_choice_as_uuid(session_id, user_choice, token):
        data = {
            "payload": {
                "type": "user_json",
                "user_json": {
                    "type": "options",
                    "selection": [user_choice]
                },
                "session_id": session_id
            }
        }
        return post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data, {"Authorization": token})
    ```

    This function is designed to send user's choice back to AI-engine through Chat API, specially in case of user getting options from multiple
    subtask options as UUID. The function takes three parameters:

        - session_id - chat session Id on DeltaV.
        - user_choice - the choice of subtask user wants AI-Engine to use.
        - token - AI-Engine fauna token to connect DeltaV or AI-Engine.

    - send_user_message function:

    ``` python
    # Function to send normal message to AI-Engine
    def send_user_message(session_id, user_message, token):
        data = {
            "payload": {
                "type": "user_message",
                "user_message": user_message
            },
            "session_id": session_id
        }
        return post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data, {"Authorization": token})
    ```

    This function is designed to send a message from the user to the chat session. This is used to submit user input as part of the chat flow.
    The session_id and token parameters are same as 'Send_user_choice_as_uuid' function, 'user_message' is the message which user wants to send to 
    the ongoing chat session.

    5. is_uuid function:

    ``` python
    # Define function to check if option is uuid (Subtask Key)
    def is_uuid(key):
        # Function to check if a string is a valid UUID
        pattern = re.compile(r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$", re.IGNORECASE)
        return pattern.match(key)
    ```

    This function checks whether the given key is in UUID (Universal Unique Identifier) format.The function uses a regular expression pattern to match the 
    standard UUID format, which consists of 32 hexadecimal characters split into five groups separated by hyphens (8-4-4-4-12).

    The function takes the 'key' parameter and returns match object if key is UUID else it returns None.

    6. stop_session functions:

    ``` python
    # Define function to stop user session
    def stop_session(session_id, token):
        data = {"payload": {"type": "stop"}}
        response = post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data, {"Authorization": token})
        print("Session stopped:", response.json())
    ```

    This function is designed to stop the ongoing deltaV chat session.

## Main Script Flow

The main script flow includes:

    1. Setting up initial tokens for authentication.
    2. Setting up a chat session on DeltaV using AI-Engine Chat API.
    3. Taking input from the user for service they want to assemble or objective to achieve.
    4. Handling the chat flow which includes sending messages and processing requests.
    5. Managing User selection from provided options.
    6. Handling special requests where agents ask the same questions back to back. (The same question is asked in agent_json and agent_info response type when user input is required.)
    7. Handling error codes provided by agent.
    8. Stopping chat session with the user.

    Chunk-by-chunk explaination:

    - Fetching initial fauna tokens using `faunatoken.py` file/library.

    ```python
    # Starting the authentication and session initiation process
    server = start_server()
    print("Please visit the following URL to authenticate:")
    print(get_auth_url())
    input("Press Enter after authentication...")
    filename = 'access_code.txt'

    with open(filename, 'r') as file:
        access_code = file.read().strip()

    if access_code:
        tokens = get_tokens(access_code)
        fauna_token = tokens[0]
        refreshed_token = tokens[1]
        token = f'Bearer {fauna_token}'
    else:
        print("Authentication failed. Please ensure you have entered the correct access code.")
        exit()
    ```

    - Setting up a Chat Session with AI_engine Chat API

    ``` python
    # User and model details
    data = {
        "email": "your_userName@fetch.ai", # replace with agentverse username
        "requestedModel": "talkative-01" # Model type for chat interaction
    }

    # Connecting to deltaV and getting session ID
    response_data = post_request("https://agentverse.ai/v1beta1/engine/chat/sessions", data, {"Authorization": token}).json()
    session_id = response_data.get('session_id')
    print("Session Id:", session_id)
    ```

    The above section of code creates payload(data) for request to start a session. Please update the following details accordingly:
        - email: Update this with your agentverse email-id. 
        - requestedModel: This is the chat model you want to make request to
    
    On the basis of details provided and POST request sent to chat API. AI-engine responds with a session-Id where we can communicate further with deltaV.
    Session-id is extracted from the response which is vital for interacting with DeltaV.

    - Taking user input from the user for service they would like to assemble/Objective they want to accomplish.

    ``` python
    # Taking user query as input
    objective = input('What Service would you like to assemble?\n')

    # Defining initial payload for quering deltaV
    data_query = {
        "payload": {
            "type": "start",
            "objective": objective,
            "context": f"User full Name: Test User\nUser email: {data['email']}\nUser location: latitude=51.5072, longitude=0.1276\n",
            "session_id": session_id
        }
    }

    # Sending query to user
    response = post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data2,{"Authorization": token} )
    # waiting to get next response from AI engine
    time.sleep(10)
    response = get_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/responses",{"Authorization": token}).json()
    ```

    This section of code is responsible for sending a start message after chat session is initialized. Below is the step-by-step explaination:
        - Taking user objective/query as input.
        - Creating a payload to make a start request to AI-engine Chat API. which includes objective, username, location and session-id.
        - POST start request with query to AI-Engine.
        - Getting latest responses from AI-Engine chat API using GET Request.

    - Selecting required service from options and sending response back to AI_engine

    ``` python
    # Getting agent response for the services options
    agent_response = response['agent_response'][0]
    agent_response_dict = json.loads(agent_response)
    # Getting Services options for user's objective
    agent_json = agent_response_dict['agent_json']

    # Taking input from user for which service to use.
    for option in agent_json['options']:
        print(f"{option['key']}: {option['value']}")
    user_choice = input("Please select an option by entering the corresponding key: \n")

    # Payload for selected service
    data_service = {
        "payload": {
            "type": "user_json",
            "user_json": {
                "type": "task_list",
                "selection": [user_choice]
            }
        }
    }

    # Submitting selected service to DeltaV
    response = post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data3,{"Authorization": token})
    ```

    The above section of code gets response for available services options for the user query or objective. Below is step-by-step guide to achieve this
        - Getting agent response for the service options
        - Displaying options to the user and taking user choice input.
        - Creating payload for selected service.
        - submitting selected service to deltaV.

    - Handling the chat flow which includes sending messages and processing responses.

    ```python
    # Setting response count to track irresponsive agent.
    no_response_count = 0
    ## Variables to track the last question and response
    last_question = ""
    last_response = ""

    while True:
    time.sleep(5)  # Wait before fetching responses to avoid overwhelming the server
    response = get_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/responses", {"Authorization": token})
    
    if response.status_code != 200:
        raise Exception(f"Error in fetching responses: Status code {response.status_code}")
    
    response = response.json()

    # Handling unresponsive deltaV
    if not response['agent_response']:
        no_response_count += 1
        if no_response_count < 10:
            continue  # Wait for a bit longer if no response yet
        else:
            print("No response from the agent.")
            stop_session(session_id, token)
            break  # Exit loop if no response after several attempts
    
    no_response_count = 0  # Reset counter on receiving a response
    ```

    This section of the script implements a loop to continuously monitor responses from the DeltaV agent within a chat session:
        - Initialize a counter for response to track empty deltaV agent responses.
        - Tracing last interaction questions, and responses to avoid asking same questions to the user.
        - The script is in continuous infinite loop repeatedly every 5 seconds unless we get 10 empty responses.
    
    ``` python
        # Reading agent response
        for agent_resp in response['agent_response']:
            agent_resp_dict = json.loads(agent_resp) #getting response dictionary from deltaV
            current_message_text = "" # Setting current message to empty string
            
            if agent_resp_dict.get('type') == 'agent_json': #handling agent_json type response
                agent_json = agent_resp_dict['agent_json']
                current_message_text = normalize_question(agent_json.get('text', '')) # Setting current message from deltaV

                # Handle options provided in agent_json
                if 'options' in agent_json and agent_json['options']:
                    option_keys = [str(option['key']) for option in agent_json['options']] # setting options keys in list to check if its UUID
                    
                    # Automatically select the first option if it's a UUID
                    if is_uuid(option_keys[0]):
                        print(f"Automatically selecting option: {option_keys[0]}")
                        send_user_choice_as_uuid(session_id, option_keys[0], token)
                        last_response = option_keys[0]  # Update last response
                        continue  # Skip the rest of the loop to wait for the next agent response
                    else:
                        # If the first option is not a UUID, prompt for user input
                        print(agent_json.get('text', '')) # printing deltaV message on terminal
                        for option in agent_json['options']:
                            print(f"{option['key']}: {option['value']}") # Printing options on terminal
                        user_choice = input("Your Response: ") # Taking user selection from options
                        send_user_message(session_id, user_choice, token) # Sending response to deltaV
                        last_response = user_choice  # Update last response
                else:
                    # No options provided
                    print(agent_json.get('text', 'Please confirm the details or provide the requested information:')) # Printing user message
                    if agent_json.get('context_json') and 'args' in agent_json['context_json']: #Printing arguments to confirm if present
                        args = agent_json['context_json']['args']
                        for key, value in args.items():
                            print(f"{key}: {value}")
                    user_confirmation = input("Your confirmation/details: ") # Confirming arguements by user
                    send_user_message(session_id, user_confirmation, token)
                    last_response = user_confirmation  # Update last response
    ```

    This section of scripts processes responses from the agent in DeltaV system:
        - The loop continuously iterates through each response and converts json string into python dictionary.
        - The script initializes `current_message_text` as an empty string to prepare for new messages.
        - This script handles different types of responses. If the response type is `agent_json`:
            - Extracts the message and normalizes it using the normalize_question function, which converts the text to lowercase and removes punctuation.
            - Checks if there are options associated with the message, if there are:
                - It extracts the option keys and checks if the first option is a UUID, indicating a subtask trigger.
                - If it is a UUID, the script automatically selects first option without user intervention, updating last_response and skipping the remaining loop to await further responses.
                - If the options are not UUIDs, the script displays them to the user and prompts for a choice, which is then sent back to DeltaV using `send_user_message`.
        - If the agent_json does not contain options (indicating a request for confirmation or information):
            - The script prints the message and, if present, details (arguments) for user confirmation.
            - It then collects user input and sends it back to DeltaV, updating last_response with the user's input for continuity.    

    ``` python
    elif agent_resp_dict.get('type') == 'agent_message': #handling agent_message type response
            agent_message = agent_resp_dict.get('agent_message', '')
            print(agent_message)
            # If agent_message repeats the last question, reuse last response
            if normalize_question(agent_message.split('?')[0]) == last_question:
                print(f"Reusing your last response: {last_response}")
                send_user_message(session_id, last_response, token)
            else: # if question not repeated taking input from user
                user_response = input("Your answer: ")
                send_user_message(session_id, user_response, token)
                last_response = user_response  # Update last response
    ```
    
    - Handling `agent_message` type response:
        - if the questions asked is same as the previous response in agent_json, it automatically sends previous response to deltav using `send_user_message` message.
        - else the input or is taken from user for the given question and sent to deltaV agent using `send_user_message` and `last_response` is stored.

    ```python
    # Stopping session in case of error.
        elif agent_resp_dict.get('type') == 'agent_error':
            agent_message = agent_resp_dict.get('agent_error')
            print(agent_message)
            stop_session(session_id, token)
    ```

    - This section of script handles `error` type response and stops the session in case of error with error message.

    ```python
    elif 'agent_info' in agent_resp_dict or agent_resp_dict.get('type') == 'stop': #handling agent_info and stop messages
            # Print agent_info or handle stop type
            info_message = agent_resp_dict.get('agent_info', '') if agent_resp_dict.get('type') == 'agent_info' else "Session stopping." 
            print(f'Agent Info : {info_message}') # Print agent info
            if 'I have completed your task! Please reset your chat session before submitting your new request.' in info_message:
                stop_session(session_id, token)
                break  # Exit loop if session is stopped
            if agent_resp_dict.get('type') == 'stop':
                stop_session(session_id, token)
                break  # Exit loop if session is stopped
    ```

    - Handling 'agent_info' and 'stop' Type Responses:
        - If the response contains 'agent_info' or the type is 'stop', the script processes these specific messages.
        - For 'agent_info' type messages, it extracts and prints the information content provided by the agent. This could be feedback, status updates, or other informative messages relevant to the user's query or the chat session.
        - If the message type is 'stop', the script prints "Session stopping." to indicate that the DeltaV session is ending.


    - Session Complete and Reset:
        - If the agent's information message indicates that the user's task has been completed (identified by a specific message, "I have completed your task! Please reset your chat session before submitting your new request."), the script triggers the stop_session function to properly close the session on the server side.
        - Similarly, if the response type is 'stop', it also calls stop_session to end the session.
        - In both cases, after stopping the session, the script breaks out of the loop, effectively ending the script's execution.

    ```python
    else:
        print("Received an unhandled response type:", agent_resp_dict.get('type')) # Handling any other message type

        # Update last_question with current message text up to a question mark
        last_question = current_message_text.split('?')[0] if '?' in current_message_text else current_message_text
    ```

    This section of script handles any other agent response and also updates the last question.It removes the options and punctuation mark from the question to check it with the current question in agent_json.

## Whole Script

    ```py copy filename="agent.py"
    # Importing required libraries
    import re
    import requests
    import time
    import json
    from faunatoken import start_server, shutdown_server, get_auth_url, get_tokens, refresh_tokens 

    # Define function to normalize questions asked by AI-engine
    def normalize_question(question):
        question_lower = question.lower()
        question_normalized = re.sub(r'[^\w\s]', '', question_lower)
        return question_normalized

    # Define function to check if a string is a valid UUID
    def is_uuid(key):
        # Ensure the key is a string
        key_str = str(key)
        pattern = re.compile(r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$", re.IGNORECASE)
        return pattern.match(key_str)

    # Function to update and refresh the access token
    def update_token():
        global token, refreshed_token
        new_tokens = refresh_tokens(refreshed_token)
        fauna_token = new_tokens[0]
        refreshed_token = new_tokens[1]
        token = f'Bearer {fauna_token}'

    # Function to handle POST requests with automatic token refresh
    def post_request(url, json_data, headers):
        global token
        response = requests.post(url, json=json_data, headers=headers)
        if response.status_code != 200:
            update_token()
            headers["Authorization"] = token
            response = requests.post(url, json=json_data, headers=headers)
        return response

    # Function to handle GET requests with automatic token refresh
    def get_request(url, headers):
        global token
        response = requests.get(url, headers=headers)
        if response.status_code != 200:
            update_token()
            headers["Authorization"] = token
            response = requests.get(url, headers=headers)
        return response

    # Functions to interact with the AI-Engine
    def send_user_choice_as_uuid(session_id, user_choice, token):
        data = {
            "payload": {
                "type": "user_json",
                "user_json": {
                    "type": "options",
                    "selection": [user_choice]
                },
                "session_id": session_id
            }
        }
        return post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data, {"Authorization": token})

    def send_user_message(session_id, user_message, token):
        data = {
            "payload": {
                "type": "user_message",
                "user_message": user_message
            },
            "session_id": session_id
        }
        return post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data, {"Authorization": token})

    def stop_session(session_id, token):
        data = {"payload": {"type": "stop"}}
        response = post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data, {"Authorization": token})
        print("Session stopped:", response.json())

    # Starting the authentication and session initiation process
    server = start_server()
    print("Please visit the following URL to authenticate:")
    print(get_auth_url())
    input("Press Enter after authentication...")
    filename = 'access_code.txt'

    with open(filename, 'r') as file:
        access_code = file.read().strip()

    if access_code:
        tokens = get_tokens(access_code)
        fauna_token = tokens[0]
        refreshed_token = tokens[1]
        token = f'Bearer {fauna_token}'
    else:
        print("Authentication failed. Please ensure you have entered the correct access code.")
        exit()

    # User and model details
    data = {
        "email": "abhi.gangani@fetch.ai",
        "requestedModel": "talkative-01"
    }

    response_data = post_request("https://agentverse.ai/v1beta1/engine/chat/sessions", data, {"Authorization": token}).json()
    session_id = response_data.get('session_id')
    print("Session Id:", session_id)

    # Taking user query as input
    objective = input('What Service would you like to assemble?\n')

    # Defining initial payload for quering deltaV
    data2 = {
        "payload": {
            "type": "start",
            "objective": objective,
            "context": f"User full Name: Test User\nUser email: {data['email']}\nUser location: latitude=51.5072, longitude=0.1276\n",
            "session_id": session_id
        }
    }

    response = post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data2,{"Authorization": token} )

    # waiting to get next response from AI engine
    time.sleep(10)

    response = get_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/responses",{"Authorization": token}).json()

    agent_response = response['agent_response'][0]
    agent_response_dict = json.loads(agent_response)
    # Getting Services options for user's objective
    agent_json = agent_response_dict['agent_json']

    # Taking input from user for which service to use.
    for option in agent_json['options']:
        print(f"{option['key']}: {option['value']}")
    user_choice = input("Please select an option by entering the corresponding key: \n")

    # Payload for selected service
    data3 = {
        "payload": {
            "type": "user_json",
            "user_json": {
                "type": "task_list",
                "selection": [user_choice]
            }
        }
    }


    # Submitting selected service to DeltaV
    response = post_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/submit", data3,{"Authorization": token})


    # Initialize variables to keep track of the last question and response
    last_question = ""
    last_response = ""
    no_response_count = 0

    # Main interaction loop

    while True:
        time.sleep(5)
        response = get_request(f"https://agentverse.ai/v1beta1/engine/chat/sessions/{session_id}/responses", {"Authorization": token})
        
        if response.status_code != 200:
            raise Exception(f"Error in fetching responses: Status code {response.status_code}")
        
        response = response.json()
        # Handling unresponsive deltaV
        if not response['agent_response']:
            no_response_count += 1
            print('Waiting for response')
            if no_response_count < 10:
                continue  # Wait for a bit longer if no response yet
            else:
                print("No response from the agent.")
                stop_session(session_id, token)
                break  # Exit loop if no response after several attempts
        
        no_response_count = 0  # Reset counter on receiving a response

        # Reading agent response
        for agent_resp in response['agent_response']:
            agent_resp_dict = json.loads(agent_resp) #getting response dictionary from deltaV
            current_message_text = "" # Setting current message to empty string
            
            if agent_resp_dict.get('type') == 'agent_json': #handling agent_json type response
                agent_json = agent_resp_dict['agent_json']
                current_message_text = normalize_question(agent_json.get('text', '')) # Setting current message from deltaV

                # Handle options provided in agent_json
                if 'options' in agent_json and agent_json['options']:
                    option_keys = [str(option['key']) for option in agent_json['options']] # setting options keys in list to check if its UUID
                    
                    # Automatically select the first option if it's a UUID
                    if is_uuid(option_keys[0]):
                        print(f"Automatically selecting option: {option_keys[0]}")
                        send_user_choice_as_uuid(session_id, option_keys[0], token)
                        last_response = option_keys[0]  # Update last response
                        continue  # Skip the rest of the loop to wait for the next agent response
                    else:
                        # If the first option is not a UUID, prompt for user input
                        print(agent_json.get('text', '')) # printing deltaV message on terminal
                        for option in agent_json['options']:
                            print(f"{option['key']}: {option['value']}") # Printing options on terminal
                        user_choice = input("Your Response: ") # Taking user selection from options
                        send_user_message(session_id, user_choice, token) # Sending response to deltaV
                        last_response = user_choice  # Update last response
                else:
                    # No options provided
                    print(agent_json.get('text', 'Please confirm the details or provide the requested information:')) # Printing user message
                    if agent_json.get('context_json') and 'args' in agent_json['context_json']: #Printing arguments to confirm if present
                        args = agent_json['context_json']['args']
                        for key, value in args.items():
                            print(f"{key}: {value}")
                    user_confirmation = input("Your confirmation/details: ") # Confirming arguements by user
                    send_user_message(session_id, user_confirmation, token)
                    last_response = user_confirmation  # Update last response
            
            elif agent_resp_dict.get('type') == 'agent_message': #handling agent_message type response
                agent_message = agent_resp_dict.get('agent_message', '')
                print(agent_message)
                # If agent_message repeats the last question, reuse last response
                if normalize_question(agent_message.split('?')[0]) == last_question:
                    print(f"Reusing your last response: {last_response}")
                    send_user_message(session_id, last_response, token)
                else: # if question not repeated taking input from user
                    user_response = input("Your answer: ")
                    send_user_message(session_id, user_response, token)
                    last_response = user_response  # Update last response

            # Stopping session in case of error.
            elif agent_resp_dict.get('type') == 'agent_error':
                agent_message = agent_resp_dict.get('agent_error')
                print(agent_message)
                stop_session(session_id, token)

            elif 'agent_info' in agent_resp_dict or agent_resp_dict.get('type') == 'stop': #handling agent_info and stop messages
                # Print agent_info or handle stop type
                info_message = agent_resp_dict.get('agent_info', '') if agent_resp_dict.get('type') == 'agent_info' else "Session stopping." 
                print(f'Agent Info : {info_message}') # Print agent info
                if 'I have completed your task! Please reset your chat session before submitting your new request.' in info_message:
                    stop_session(session_id, token)
                    break  # Exit loop if session is stopped
                if agent_resp_dict.get('type') == 'stop':
                    stop_session(session_id, token)
                    break  # Exit loop if session is stopped

            else:
                print("Received an unhandled response type:", agent_resp_dict.get('type')) # Handling any other message type

            # Update last_question with current message text up to a question mark
            last_question = current_message_text.split('?')[0] if '?' in current_message_text else current_message_text
    ```

Save this script as chatAPI.py and replace ‘email’ and ‘fauna_token’ in the script.

Running this app on the terminal:
    1. Locate the directory where the script is located.
    2. Run script using python `chatapi.py` and authenticate user using provided link.
    3. Press enter after authenticating and provide the objective of the conversation to deltaV.
    4. Select the key of the service you want to use.
    5. Confirm/ Reject the details whenever asked.
    6. Reply back to the agent when a question is asked.
    7. When the final response is received, type OK or stop to be sent to the deltaV agent.

Please refer below images for sample chat session with AI_engine Chat_API

![](../../../src/images/APIs/chatAPI1.png)

![](../../../src/images/APIs/chatAPI2.png)



