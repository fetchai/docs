import { Callout } from 'nextra/components'

# Indexer / Ledger SubQuery

##  Overview

The **ledger-subquery** is a [SubQuery-based ↗️](https://www.subquery.network/) indexer for the [Fetch ledger ↗️](/concepts/fetch-network/ledger/intro). An indexer is a tool which allows to create a structured list of data items (i.e., an index) that allows to quickly search and retrieve information. In this context, the ledger-subquery acts as an indexer specifically designed to optimize data accessibility by providing a [Graphql ↗️](https://www.subquery.network/) API for querying tracked entities within the Fetch ledger. This enables direct and efficient retrieval of data, simplifying the process for developers who need to access information from the ledger.

A detailed list of tracked entities is accessible via the [schema.graphql file ↗️](https://github.com/fetchai/ledger-subquery/blob/main/schema.graphql).

    <Callout type="info" emoji="ℹ️">
      You can learn more on how to [run ↗️](https://academy.subquery.network/run_publish/run.html) or change the SubQuery Project, get your own custom GraphQL API for your app, by [visiting the SubQuery Academy ↗️](https://academy.subquery.network/) for further documentation.
    </Callout>

    <Callout type="info" emoji="ℹ️">
      Check out the [GitHub repository ↗️](https://github.com/fetchai/ledger-subquery) or head over to the [Indexer references ↗️](/references#indexer) for additional information.
    </Callout>

## Architecture: Components Diagram

The ledger-subquery architecture comprises several key components that work together to provide a GraphQL API for querying data from the Fetch ledger, enabling efficient data retrieval and interaction with the Fetch ledger.

Here, we outline the components and their relationships:

![subquery architecture component diagram](../../../src/images/docs/indexer/architecture_legend_1.svg)

![subquery architecture component diagram](../../../src/images/docs/indexer/architecture_legend_2.svg)

### Key Components

The system architecture core is the **SubQuery Node** and showcases a GraphQL-based interface for client interactions and a  backend for data management and storage.

The entry point for users to interact with the system is the **Public GraphQL Endpoint** through which they can submit GraphQL queries. The **Apollo Server** receives the GraphQL query and processes it based on the GraphQL schema generated by **Postgraphile**. This latter one acts as a translator between the structure of the PostgreSQL database (i.e., **PostgresDB**) and the GraphQL query language. It automatically generates a GraphQL schema based on the structure of the database which allows to efficiently query and manipulate data through the GraphQL interface. In few words, it simplifies the process of exposing the PostgresDB data as GraphQL APIs.

The data retrieval process starts when the **SubQuery Node** receives the GraphQL query from the Apollo Server. Based on the query, the **Indexer Manager** and **Fetch service** work together within the SubQuery Node to efficiently retrieve and process the data. The **Indexer Manager** oversees the management of various indexers selecting the most suitable ones based on the incoming GraphQL query and coordinates their activities. Once the Indexer Manager identifies the required indexers, the **Fetch service** retrieves data from the specified sources to fetch the requested information (e.g., **Fetch Ledger Node**) thanks to the **public RPC endpoint** which works as the gateway to external data. Once the data is fetched, it is returned to the Indexer Manager for further processing and storage.

The received data is the processed by the Indexer Manager and it is then stored by the **Store Service** in the PostgresDB. Indeed, the Store Service acts acts as the bridge between this two components by storing and retrieving data based on requests from the Indexer Manager.

Once a query from the GraphQL API is received, the data requested is retrieved by the Store Service, which in turn fetches it from the PostgresDB through the **Private DB Connection**. By isolating the database interaction with this private connection, the system enhances security, performance, and reliability. The data is then formatted into a structure that aligns with the original GraphQL query by the SubQuery Node prepares this data in a format suitable for the GraphQL API to process and return it to the client. The data is then sent back to the Apollo Server. This last component takes in this data, combines it with the information from the GraphQL query, and constructs the final GraphQL response which is finally transmitted back to the client who initiated the query.

This architecture enables efficient data retrieval and querying, providing a powerful tool for developers to interact with the Fetch ledger.
