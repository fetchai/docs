import {Callout} from 'nextra/components'

# Communicating with other agents üì±ü§ñ

## Introduction

Communication is an essential feature agent network. It allows agents to work together, exchange information, and forms an organic marketplace.

In this guide, we will explore two methods of communication between agents:

    - **Local communication**.
    - **Remote communication** via the [Almanac Contract ‚ÜóÔ∏è](/references/contracts/uagents-almanac/almanac-overview)Ô∏è, and the Agentverse [Mailroom / IoT Gateway üì´ ‚ÜóÔ∏è](/concepts/agent-services/agent-mail)Ô∏è service.

We want to start by introducing you to the concept of **local communication**. This is the first step you would need to undertake to familiarize yourself with the code syntax we will be using in the **remote communication** section.

    <Callout type="info" emoji="‚ÑπÔ∏è">
      Local communication is important for debugging purposes.
    </Callout>

**Let's get started!**

## AI Agents: Local Communication

### Walk-through

The first step to better understand how agents communicate is to introduce how 2 agents perform a local communication. Let‚Äôs consider a basic example in which two agents say hello to each other.

1. First of all, let's create a Python script for this task and name it by running: `touch agents_communication.py`

2. Then, we import  `Agent`, `Context`, `Bureau`, and `Model` from the uagents library and we then define the message structure for messages to be exchanged between the agents using the class `Model`.

```py copy
from uagents import Agent, Bureau, Context, Model

class Message(Model):
    message: str
   ```

The `Message` class defined the structure and of message we can receive, in this example it's just a string, but it could be a simple int, or a complex object too.

3. Now we create two agent instances, `alice` and `bob`, with `name` and `seed` parameters.

 ```py
   alice = Agent(name="alice", seed="alice recovery phrase")
   bob = Agent(name="bob", seed="bob recovery phrase")
```

In this example we're running multiple agents from one file.

3. Let's now define `alice`'s behaviors. We need to define a function for `alice` to send messages to `bob` periodically:

```py copy
@alice.on_interval(period=3.0)
async def send_message(ctx: Context):
   await ctx.send(bob.address, Message(message="hello there bob"))
   ```

We can use the `.on_interval()` decorator to define a coroutine `send_message()` function that will be called every 3 seconds. The coroutine function sends a message to `bob` using the `ctx.send()` method of the `Context` object.

4. We then need to define a `alice_message_handler()` function for `alice` to manage incoming messages:

```py copy
@alice.on_message(model=Message)
async def alice_message_handler(ctx: Context, sender: str, msg: Message):
    ctx.logger.info(f"Received message from {sender}: {msg.message}")
   ```

This defines the coroutine function `alice_message_handler()` that serves as a message handler for `alice`. It is triggered whenever alice receives a message of type `Message`.

5. Let's now define the behavior of our second agent, `bob`:

```py copy
@bob.on_message(model=Message)
async def bob_message_handler(ctx: Context, sender: str, msg: Message):
    ctx.logger.info(f"Received message from {sender}: {msg.message}")
    await ctx.send(alice.address, Message(message="hello there alice"))
   ```

Same as Alice however, we make `bob` compose a response message to be sent back using the `ctx.send()` method with `alice.address` as the recipient address and an instance of the `Message` model as the message payload.

It would also be valid to respond to the sender:

     ```py
     await ctx.send(sender.address, Message(message="hello there alice"))
     ```

6. Let's then use the `Bureau` class to create a `Bureau` object. This will allow us to run agents together in the same script.

```py copy
bureau = Bureau()
bureau.add(alice)
bureau.add(bob)

if __name__ == "__main__":
    bureau.run()
   ```

7. Save the script.

The complete script should be looking as follows:

```py copy filename="agents_communication.py"
from uagents import Agent, Bureau, Context, Model

class Message(Model):
    message: str

alice = Agent(name="alice", seed="alice recovery phrase")
bob = Agent(name="bob", seed="bob recovery phrase")

@alice.on_interval(period=3.0)
async def send_message(ctx: Context):
   await ctx.send(bob.address, Message(message="hello there bob"))

@alice.on_message(model=Message)
async def alice_message_handler(ctx: Context, sender: str, msg: Message):
    ctx.logger.info(f"Received message from {sender}: {msg.message}")

@bob.on_message(model=Message)
async def bob_message_handler(ctx: Context, sender: str, msg: Message):
    ctx.logger.info(f"Received message from {sender}: {msg.message}")
    await ctx.send(alice.address, Message(message="hello there alice"))

bureau = Bureau()
bureau.add(alice)
bureau.add(bob)
if __name__ == "__main__":
    bureau.run()
```

We are now ready to run the script: `python agents_communication.py`

The output would be:

    ```
    [alice]: Received message from agent1q0mau8vkmg78xx0sh8cyl4tpl4ktx94pqp2e94cylu6haugt2hd7j9vequ7: hello there alice
    [  bob]: Received message from agent1qww3ju3h6kfcuqf54gkghvt2pqe8qp97a7nzm2vp8plfxflc0epzcjsv79t: hello there bob
    [alice]: Received message from agent1q0mau8vkmg78xx0sh8cyl4tpl4ktx94pqp2e94cylu6haugt2hd7j9vequ7: hello there alice
    [  bob]: Received message from agent1qww3ju3h6kfcuqf54gkghvt2pqe8qp97a7nzm2vp8plfxflc0epzcjsv79t: hello there bob
    [alice]: Received message from agent1q0mau8vkmg78xx0sh8cyl4tpl4ktx94pqp2e94cylu6haugt2hd7j9vequ7: hello there alice
    ```


## AI Agents Remote Communication: the Almanac Contract

To speak, search or be found your agent must register to the  [Almanac contract ‚ÜóÔ∏è](/references/contracts/uagents-almanac/almanac-overview)Ô∏è. Agents then query this to retrieve an HTTP endpoint for a recipient agent. [Registration in the Almanac ‚ÜóÔ∏è](/guides/agents/register-in-almanac) requires paying a small fee, so make sure to have enough funds to allow for this. You can query the almanac now, by using the search feature on [agentverse.ai ‚ÜóÔ∏è](https://www.agentverse.ai).

Whenever an agent registers in the Almanac, it must specify the service [endpoints ‚ÜóÔ∏è](/references/contracts/uagents-almanac/endpoints)Ô∏è alongside a weight parameter for each endpoint provided. Agents trying to communicate with your agent, will choose the service endpoints using a weighted random selection.

Here, we show you how to create two agents and make them remotely communicate by registering and using the Almanac Contract.

### Walk-through

The first step would be to create two different Python scripts for this task, each one representing a remote agent:

    Bob: `touch remote_agents_bob.py`

    Alice: `touch remote_agents_alice.py`

Let's start by defining the script for **alice**.

#### Alice

1. In `remote_agents_alice.py` script, we would need to import the necessary classes from the `uagents` (`Agent`, `Context`, and `Model`) and from `uagents.setup` (`fund_agent_if_low`). We then need to define the message structure for messages to be exchanged between agents using the class `Model`, as well as the `RECIPIENT_ADDRESS` (bob's address). Note that if you don't know bob's address yet, you can use `print(bob.address)` after defining agent `bob` to get this information. This is the address towards which `alice` will send messages:

```py copy
from uagents import Agent, Context, Model
from uagents.setup import fund_agent_if_low

class Message(Model):
    message: str

RECIPIENT_ADDRESS="agent1q2kxet3vh0scsf0sm7y2erzz33cve6tv5uk63x64upw5g68kr0chkv7hw50"
   ```

2. Let's now create our agent, `alice`, by providing `name`, `seed`, `port`, and `endpoint`. Also, make sure it has enough funds to register in the Almanac contract:

```py copy
alice = Agent(
    name="alice",
    port=8000,
    seed="alice secret phrase",
    endpoint=["http://127.0.0.1:8000/submit"],
)

fund_agent_if_low(alice.wallet.address())
   ```

On the Fetch.ai testnet, you can use the `fund_agent_if_low` function. This checks if the balance of the uAgent's wallet is below a certain threshold, and if so, sends a transaction to fund the wallet with a specified amount of cryptocurrency. In this case, it checks if the balance of `alice`'s wallet is low and funds it if necessary.

3. We are ready to define `alice`'s behaviors. Let's start with a function for `alice` to send messages:

```py copy
@alice.on_interval(period=2.0)
async def send_message(ctx: Context):
    await ctx.send(RECIPIENT_ADDRESS, Message(message="hello there bob")
   ```

Here, the `.on_interval()` decorator schedules the `send_message()` function to be run every 2 seconds. Inside the function, there is an asynchronous call indicated by the `ctx.send()` method. This call sends a message with the content `"hello there bob"` to the `RECIPIENT_ADDRESS`.

4. We then need to define a function for `alice` to handle incoming messages from other agents:

```py copy
@alice.on_message(model=Message)
async def message_handler(ctx: Context, sender: str, msg: Message):
    ctx.logger.info(f"Received message from {sender}: {msg.message}")

if __name__ == "__main__":
    alice.run()
   ```

Here, we have used the `.on_message()` decorator to register the `message_handler()` coroutine function as a handler for incoming messages of type `Message`.

The `message_handler()` function takes three arguments: `ctx`, `sender`, and `msg`. Inside this function, we call the `ctx.logger.info()` method to log information about the received message, including the sender and message content.

5. We can now save the script.

The overall script for alice agent should be looking as follows:

```py copy filename="remote_agents_alice.py"
from uagents import Agent, Context, Model
from uagents.setup import fund_agent_if_low

class Message(Model):
    message: str

RECIPIENT_ADDRESS="agent1q2kxet3vh0scsf0sm7y2erzz33cve6tv5uk63x64upw5g68kr0chkv7hw50"

alice = Agent(
    name="alice",
    port=8000,
    seed="alice secret phrase",
    endpoint=["http://127.0.0.1:8000/submit"],
)

fund_agent_if_low(alice.wallet.address())

@alice.on_interval(period=2.0)
async def send_message(ctx: Context):
    await ctx.send(RECIPIENT_ADDRESS, Message(message="hello there bob"))

@alice.on_message(model=Message)
async def message_handler(ctx: Context, sender: str, msg: Message):
    ctx.logger.info(f"Received message from {sender}: {msg.message}")

if __name__ == "__main__":
    alice.run()
```

We can now proceed by writing the script for agent `bob`.

#### Bob

1. In `remote_agents_bob.py` script, import the necessary classes from the `uagents` and `uagents.setup`. Then, define the message structure for messages to be exchanged between the agents using the `Model` class, as well as our second uAgent, `bob`, by providing `name`, `seed`, `port`, and `endpoint`. Make sure it has enough funds to register in the Almanac contract:

```py copy
from uagents import Agent, Context, Model
from uagents.setup import fund_agent_if_low

class Message(Model):
    message: str

bob = Agent(
    name="bob",
    port=8001,
    seed="bob secret phrase",
    endpoint=["http://127.0.0.1:8001/submit"],
)

fund_agent_if_low(bob.wallet.address())
   ```

2. Let's now define a function for `bob` to handle incoming messages and answering back to the sender:

```py copy
@bob.on_message(model=Message)
async def message_handler(ctx: Context, sender: str, msg: Message):
    ctx.logger.info(f"Received message from {sender}: {msg.message}")

    await ctx.send(sender, Message(message="hello there alice"))

if __name__ == "__main__":
    bob.run()
   ```

Here, we have defined an asynchronous `message_handler()` function for bob to handle incoming messages from other uAgents. The function is decorated with `.on_message()`, and it is triggered whenever a message of type `Message` is received by `bob`. When a message is received, the handler function logs the sender's address and the content of the message. It then sends a response back to the sender using the `ctx.send()` with a new message. The response message contains the `Message` data model with a `"hello there alice"` message.

3. Save the script.

The overall script for `bob` should be looking as follows:

```py copy filename="remote_agents_bob.py"
from uagents.setup import fund_agent_if_low
from uagents import Agent, Context, Model

class Message(Model):
    message: str

bob = Agent(
    name="bob",
    port=8001,
    seed="bob secret phrase",
    endpoint=["http://127.0.0.1:8001/submit"],
)

fund_agent_if_low(bob.wallet.address())

@bob.on_message(model=Message)
async def message_handler(ctx: Context, sender: str, msg: Message):
    ctx.logger.info(f"Received message from {sender}: {msg.message}")

    await ctx.send(sender, Message(message="hello there alice"))

if __name__ == "__main__":
    bob.run()
```

#### Run the scripts

In different terminal windows, first run `bob` and then `alice`. They will register automatically in the Almanac contract using their funds. The received messages will print out in each terminal:

    Terminal 1: `python remote_agents_bob.py`

    Terminal 2: `python remote_agents_alice.py`

The output will depend on the terminal:

- **Alice**:

```
[alice]: Received message from agent1q2kxet3vh0scsf0sm7y2erzz33cve6tv5uk63x64upw5g68kr0chkv7hw50: hello there alice
[alice]: Received message from agent1q2kxet3vh0scsf0sm7y2erzz33cve6tv5uk63x64upw5g68kr0chkv7hw50: hello there alice
[alice]: Received message from agent1q2kxet3vh0scsf0sm7y2erzz33cve6tv5uk63x64upw5g68kr0chkv7hw50: hello there alice
  ```

- **Bob**:

```
[  bob]: Received message from agent1qdp9j2ev86k3h5acaayjm8tpx36zv4mjxn05pa2kwesspstzj697xy5vk2a: hello there bob
[  bob]: Received message from agent1qdp9j2ev86k3h5acaayjm8tpx36zv4mjxn05pa2kwesspstzj697xy5vk2a: hello there bob
[  bob]: Received message from agent1qdp9j2ev86k3h5acaayjm8tpx36zv4mjxn05pa2kwesspstzj697xy5vk2a: hello there bob
  ```


### Before we go on...

As we touched on before in [Register in Alamanac](/guides/agents/register-in-almanac), when the agent uses `.run()` fuction this tells the uAgent library to register the agent to the Almanac. It's simple, agents initialise themselves, and register to a service which acts as a search engine for agents (the almanac) then, when agents receive messages they can respond.

## Conclusion

In this comprehensive guide, we explored two different methods of communication for AI Agents using the `uagents` library:

    - **Local communication**.
    - **Remote communication** via the Almanac Contract.

For _local communication_, we learned how to use the `uagents` library to create two agents, `alice` and `bob`, and enable them to exchange messages with one another. We defined the message structure using the `Model` class and implemented message handlers for both agents. By running the script we observed their real-time message exchange.

Next, we delved into _remote communication_, which facilitates interaction between agents through the Almanac Contract. This method requires registering the agents in the Almanac Contract and querying for **HTTP endpoints** for communication. By running the scripts separately, we could observe the real-time messages exchange, fostering a decentralized network of interacting agents.

In addition, we introduced the [Agentverse mailbox service ‚ÜóÔ∏è](/concepts/agent-services/agent-mail) to facilitate remote communication through the usage of the [Agentverse Explorer ‚ÜóÔ∏è](/concepts/agent-services/agent-explorer). We demonstrated the communication process by creating `alice` and `bob` scripts and utilizing their respective API keys to communicate remotely via such service. The decentralized network enabled messages transfer and information sharing between the remote agents. By following this last approach, users can leverage the power of the Agentverse Explorer to build intricate networks of remotely interacting agents.

This opens up a world of possibilities for collaborative decision-making, distributed problem-solving, and decentralized coordination across a myriad of applications and domains. With this newfound knowledge, developers can harness the potential of autonomous agents to create innovative solutions and use cases in a rapidly evolving digital and decentralized landscape.
