# Oracles ðŸ”®

## Introduction

**Oracles** are entities that can update state variables in smart contracts and whose goal is usually to accurately estimate or predict some real world quantity or quantities. These quantities can then be used in the logic of other smart contracts. This guide shows how to write a CosmPy script that deploys and updates an oracle contract with a coin price, and another script that deploys a contract that queries this coin price.

## Getting started

### Aerial oracle

1. First of all, create a Python script and name it: `touch aerial_oracle.py`
2. We need to download the binaries for both contracts, which can be done as follows:

    ```
    wget https://raw.githubusercontent.com/fetchai/agents-aea/develop/packages/fetchai/contracts/oracle/build/oracle.wasm
    wget https://raw.githubusercontent.com/fetchai/agents-aea/develop/packages/fetchai/contracts/oracle_client/build/oracle_client.wasm
    ```

3. We would then also require the following imports:

    ```py copy
    from time import sleep
    import requests
    from cosmpy.aerial.client import LedgerClient, NetworkConfig
    from cosmpy.aerial.contract import LedgerContract
    from cosmpy.aerial.faucet import FaucetApi
    from cosmpy.aerial.wallet import LocalWallet
    from cosmpy.crypto.address import Address
    ```

4. We then need to choose a data source for the coin price, the update interval, the decimal precision, and the decimal timeout for the oracle value:

    ```py copy
    COIN_PRICE_URL = (
        "https://api.coingecko.com/api/v3/simple/price?ids=fetch-ai&vs_currencies=usd"
    )
    UPDATE_INTERVAL_SECONDS = 10
    ORACLE_VALUE_DECIMALS = 5
    DEFAULT_TIMEOUT = 60.0
    ```

5. We then proceed and define a `_parse_commandline()` by first importing the argparse module, which is a standard Python module for parsing command-line arguments.

    ```py copy
    def _parse_commandline():
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "contract_path", help="The path to the oracle contract to upload"
        )
        parser.add_argument(
            "contract_address",
            nargs="?",
            type=Address,
            help="The address of the oracle contract if already deployed",
        )
        return parser.parse_args()
    ```

   This first creates an argument `parser` object. The `ArgumentParser` class provides a way to specify the arguments your script should accept and automatically generates help messages and error messages. We then use `add_argument()` to add a positional argument named `contract_path`. This argument is required and should be a path to the oracle contract that you want to upload. The help argument provides a description of what this argument does. We further add another positional argument named `contract_address`. This argument is optional (`nargs="?"` allows it to be omitted), and it should be of type `Address`. The `type` argument specifies the type of the argument. In this case, `Address` is a custom type or class used to represent addresses. The `help` argument provides a description of what this argument does. At the end, we parse the command-line arguments provided when the script is executed. It returns an object that contains the values of the parsed arguments.




